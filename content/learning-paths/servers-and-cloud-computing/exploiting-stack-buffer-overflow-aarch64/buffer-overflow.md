---
title: Stack Buffer Overflow
weight: 5

### FIXED, DO NOT MODIFY
layout: learningpathall
---

Arrays that are local function variables are allocated on the stack. When a
programming error results in the program writing to an array index beyond the
size of that array, a
[stack buffer overflow](https://en.wikipedia.org/wiki/Stack_buffer_overflow)
happens.

Let's look at an example:

```C
#include <string.h>

__attribute__((noinline))
char f(char *src) {
    char buffer[8];
    strcpy(buffer, src);
    return buffer[2];
}

// Note that a 0 byte is automatically appended.
//                     00000000011111111112222
//                     12345678901234567890123
char many_chars[24] = "These are 24 chars. yes";
int main() {
    f(many_chars);
    return 0;
}
```
Save it as file `stack-buffer-overflow.c`.

Compile it with the following command at your docker prompt:

```bash { command_line="root@7a8fb34f810e:/armlearningpaths|2-3" }
clang -g -O1 stack-buffer-overflow.c -o stack-buffer-overflow
```

Now run this program:
```bash { command_line="root@7a8fb34f810e:/armlearningpaths|2-3" }
./stack-buffer-overflow
Bus error
```

The program crashed with a bus error. What happened exactly?

### Let's dive deeper using a debugger

Let's use the gdb debugger to try and find out.
Start the gdb debugger:

```bash { command_line="root@7a8fb34f810e:/armlearningpaths|2-5" }
gdb -q ./stack-buffer-overflow
Reading symbols from ./stack-buffer-overflow...
(gdb) 
```

Let's put a breakpoint on the first instruction of function `f`. If you simply
execute `break f` at the gdb prompt, it will set the breakpoint after the function prologue.
We don't want that, as we want to investigate what happens during the function prologue.
To set a breakpoint, perform the following steps at the gdb prompt:

```text { output_lines = "2" }
(gdb) break main
Breakpoint 1 at 0x784: file stack-buffer-overflow.c, line 15.
```

```text { output_lines = "2-7" }
(gdb) run
Starting program: /armlearningpaths/stack-buffer-overflow
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/aarch64-linux-gnu/libthread_db.so.1".

Breakpoint 1, main () at stack-buffer-overflow.c:15
15          f(many_chars);
```

```text { output_lines = "2-13" }
(gdb) disass f
Dump of assembler code for function f:
   0x0000aaaaaaaa0754 <+0>:     sub     sp, sp, #0x20
   0x0000aaaaaaaa0758 <+4>:     stp     x29, x30, [sp, #16]
   0x0000aaaaaaaa075c <+8>:     add     x29, sp, #0x10
   0x0000aaaaaaaa0760 <+12>:    mov     x1, x0
   0x0000aaaaaaaa0764 <+16>:    add     x0, sp, #0x8
   0x0000aaaaaaaa0768 <+20>:    bl      0xaaaaaaaa0630 <strcpy@plt>
   0x0000aaaaaaaa076c <+24>:    ldp     x29, x30, [sp, #16]
   0x0000aaaaaaaa0770 <+28>:    ldrb    w0, [sp, #10]
   0x0000aaaaaaaa0774 <+32>:    add     sp, sp, #0x20
   0x0000aaaaaaaa0778 <+36>:    ret
End of assembler dump.
```

This shows that the first instruction of function `f` is located at address
`0x0000aaaaaaaa0754`. Let's explicitly put a breakpoint there:

```text { output_lines = "2" }
(gdb) break *0x0000aaaaaaaa0754
Breakpoint 2 at 0xaaaaaaaa0754: file stack-buffer-overflow.c, line 4.
```

Now let's continue running the program so it runs until the start of function
`f`, where it should hit the breakpoint on the first instruction.

```text { output_lines = "2-6" }
(gdb) cont
Continuing.

Breakpoint 2, f (src=0xaaaaaaab1038 <many_chars> "These are 24 chars. yes") at stack-buffer-overflow.c:4
4       char f(char *src) {
```

```text { output_lines = "2-13" }
(gdb) disass
Dump of assembler code for function f:
=> 0x0000aaaaaaaa0754 <+0>:     sub     sp, sp, #0x20
   0x0000aaaaaaaa0758 <+4>:     stp     x29, x30, [sp, #16]
   0x0000aaaaaaaa075c <+8>:     add     x29, sp, #0x10
   0x0000aaaaaaaa0760 <+12>:    mov     x1, x0
   0x0000aaaaaaaa0764 <+16>:    add     x0, sp, #0x8
   0x0000aaaaaaaa0768 <+20>:    bl      0xaaaaaaaa0630 <strcpy@plt>
   0x0000aaaaaaaa076c <+24>:    ldp     x29, x30, [sp, #16]
   0x0000aaaaaaaa0770 <+28>:    ldrb    w0, [sp, #10]
   0x0000aaaaaaaa0774 <+32>:    add     sp, sp, #0x20
   0x0000aaaaaaaa0778 <+36>:    ret
End of assembler dump.
```

Let's see what the value of the key register `sp`, `x29` and `x30` is
before any instructions are executed in function `f`

```text { output_lines = "2-13" }
(gdb) info registers sp x29 x30
sp             0xfffffffff5a0      0xfffffffff5a0
x29            0xfffffffff5a0      281474976708000
x30            0xaaaaaaaa0790      187649984432016
```

Let's now step through the 3 instructions in the function prologue.

```text { output_lines = "2-13" }
(gdb) nexti 3
0x0000aaaaaaaa0760 in f (src=0xaaaaaaab1038 <many_chars> "These are 24 chars. yes") at stack-buffer-overflow.c:4
4       char f(char *src) {
```

```text { output_lines = "2-13" }
(gdb) disass
Dump of assembler code for function f:
   0x0000aaaaaaaa0754 <+0>:     sub     sp, sp, #0x20
   0x0000aaaaaaaa0758 <+4>:     stp     x29, x30, [sp, #16]
   0x0000aaaaaaaa075c <+8>:     add     x29, sp, #0x10
=> 0x0000aaaaaaaa0760 <+12>:    mov     x1, x0
   0x0000aaaaaaaa0764 <+16>:    add     x0, sp, #0x8
   0x0000aaaaaaaa0768 <+20>:    bl      0xaaaaaaaa0630 <strcpy@plt>
   0x0000aaaaaaaa076c <+24>:    ldp     x29, x30, [sp, #16]
   0x0000aaaaaaaa0770 <+28>:    ldrb    w0, [sp, #10]
   0x0000aaaaaaaa0774 <+32>:    add     sp, sp, #0x20
   0x0000aaaaaaaa0778 <+36>:    ret
End of assembler dump.
```

What have the 3 instructions in the prologue done?

1. `sub     sp, sp, #0x20`

   moves the stack pointer downwards by `0x20` = 32 bytes. From having glanced
   through the source code and disassembly of function `f`, we expect that 2
   times 8 bytes = 16 bytes are needed to store `x29` and `x30`. Furthermore
   array `buffer` is 8 bytes long. So, in total 24 bytes should be needed on the
   frame for function `f`.

   Why does the code reserve 32 bytes then? Well, the
   [AArch64 PCS ABI](https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst#6451universal-stack-constraints)
   specifies that the stack pointer must always be aligned to a 16-byte
   boundary, so the compiler has no choice but to round up the minimum of 24
   bytes to the next higher 16-byte boundary, which is 32.
2. `stp     x29, x30, [sp, #16]`

   stores the value of `x29` and `x30` on the stack as they will get clobbered
   by the call to `strcpy`.

3. `add     x29, sp, #0x10`

   sets the frame pointer (always in register `x29`) for the frame of function
   `f` to be 16 bytes (`0x10`) higher than the stack pointer.

{{% notice "exercise 3" %}}

Draw the frame layout of function `f` at this point, including where the stack
pointer and the frame pointer point to.

{{% /notice %}}

TODO: find a way to hide the answer

```text
\ 
     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
     |       unused          |  buffer               | x29 of previous function | return address x30 |
     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 sp+:  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
       ^                                               ^
       |                                               |
       sp                                             x29

```

Let's print the content of the frame `f` at this point. We know the frame is 32 bytes long.
Let's print it as if it were 4 64-bit values:

```text { output_lines = "2-13" }
(gdb) x/4gx $sp
0xfffffffff580: 0x0000aaaaaaab0dd0      0x0000fffff7ffe040
0xfffffffff590: 0x0000fffffffff5a0      0x0000aaaaaaaa0790
```

That looks like expected: the unused part and variable `buffer` seems to contain
arbitrary bits at this point.

Then the old value of `x29` is `0x0000fffffffff5a0` as was indeed printed by gdb
when we asked the value at the start of the function. Similarly, the value of
x30 on the stack also matches with what was printed at the start of the
function.

### strcpy writing beyond the bounds of the buffer

In the stack layout we have drawn in exercise 3, we see that 8 bytes have been
allocated on the stack for `buffer`. Immediately after on the stack, the old
values that need to be restored at the end of the function of `x29` (the frame
pointer) and `x30` (the return address) are stored.

If we look again at the source code at the start of this section, we can see that
`strcpy` is going to write a string of 24 bytes in `buffer`. Now that we know the
stack layout, it is clear that the old values of `x29` and `x30` on the stack will
be overwritten with bytes from the copied string. Let's see if we can see that
happening in the debugger.

```text { output_lines = "2-13" }
(gdb) nexti
6           strcpy(buffer, src);
```

```text { output_lines = "2-13" }
(gdb) nexti
0x0000aaaaaaaa0768      6           strcpy(buffer, src);
```

```text { output_lines = "2-13" }
(gdb) disass
Dump of assembler code for function f:
   0x0000aaaaaaaa0754 <+0>:     sub     sp, sp, #0x20
   0x0000aaaaaaaa0758 <+4>:     stp     x29, x30, [sp, #16]
   0x0000aaaaaaaa075c <+8>:     add     x29, sp, #0x10
   0x0000aaaaaaaa0760 <+12>:    mov     x1, x0
   0x0000aaaaaaaa0764 <+16>:    add     x0, sp, #0x8
=> 0x0000aaaaaaaa0768 <+20>:    bl      0xaaaaaaaa0630 <strcpy@plt>
   0x0000aaaaaaaa076c <+24>:    ldp     x29, x30, [sp, #16]
   0x0000aaaaaaaa0770 <+28>:    ldrb    w0, [sp, #10]
   0x0000aaaaaaaa0774 <+32>:    add     sp, sp, #0x20
   0x0000aaaaaaaa0778 <+36>:    ret
End of assembler dump.
```

We are now right before the call to the strcpy function will be made. Let it
execute, after which we will check if indeed the value of the saved `x29` and
`x30` registers on the stack will be overwritten.

```text { output_lines = "2-13" }
(gdb) nexti
7           return buffer[2];
```

```text { output_lines = "2-13" }
(gdb) disass
Dump of assembler code for function f:
   0x0000aaaaaaaa0754 <+0>:     sub     sp, sp, #0x20
   0x0000aaaaaaaa0758 <+4>:     stp     x29, x30, [sp, #16]
   0x0000aaaaaaaa075c <+8>:     add     x29, sp, #0x10
   0x0000aaaaaaaa0760 <+12>:    mov     x1, x0
   0x0000aaaaaaaa0764 <+16>:    add     x0, sp, #0x8
   0x0000aaaaaaaa0768 <+20>:    bl      0xaaaaaaaa0630 <strcpy@plt>
=> 0x0000aaaaaaaa076c <+24>:    ldp     x29, x30, [sp, #16]
   0x0000aaaaaaaa0770 <+28>:    ldrb    w0, [sp, #10]
   0x0000aaaaaaaa0774 <+32>:    add     sp, sp, #0x20
   0x0000aaaaaaaa0778 <+36>:    ret
End of assembler dump.
```


```text { output_lines = "2-13" }
(gdb) x/4gx $sp
0xfffffffff580: 0x0000aaaaaaab0dd0      0x7261206573656854
0xfffffffff590: 0x6168632034322065      0x00736579202e7372
```

Indeed, the values of where `x29` and `x30` are stored have changed! Let's print
out this same memory, interpreted as ASCII characters to see if indeed those
hexadecimal numbers correspond to the string in the source program that we
expect.

```text { output_lines = "2-13" }
(gdb) x/32c $sp
0xfffffffff580: -48 '\320'      13 '\r' -85 '\253'      -86 '\252'      -86 '\252'      -86 '\252'      0 '\000'        0 '\000'
0xfffffffff588: 84 'T'  104 'h' 101 'e' 115 's' 101 'e' 32 ' '  97 'a'  114 'r'
0xfffffffff590: 101 'e' 32 ' '  50 '2'  52 '4'  32 ' '  99 'c'  104 'h' 97 'a'
0xfffffffff598: 114 'r' 115 's' 46 '.'  32 ' '  121 'y' 101 'e' 115 's' 0 '\000'
```

Indeed!

The next instruction that will be executed, `ldp x29, x30, [sp, #16]`, will
restore the old values of `x29` and `x30` from the stack.

```text { output_lines = "2-13" }
(gdb) nexti
0x0000aaaaaaaa0770 in f (src=<optimized out>) at stack-buffer-overflow.c:7
7           return buffer[2];
```

```text { output_lines = "2-13" }
(gdb) disass
Dump of assembler code for function f:
   0x0000aaaaaaaa0754 <+0>:     sub     sp, sp, #0x20
   0x0000aaaaaaaa0758 <+4>:     stp     x29, x30, [sp, #16]
   0x0000aaaaaaaa075c <+8>:     add     x29, sp, #0x10
   0x0000aaaaaaaa0760 <+12>:    mov     x1, x0
   0x0000aaaaaaaa0764 <+16>:    add     x0, sp, #0x8
   0x0000aaaaaaaa0768 <+20>:    bl      0xaaaaaaaa0630 <strcpy@plt>
   0x0000aaaaaaaa076c <+24>:    ldp     x29, x30, [sp, #16]
=> 0x0000aaaaaaaa0770 <+28>:    ldrb    w0, [sp, #10]
   0x0000aaaaaaaa0774 <+32>:    add     sp, sp, #0x20
   0x0000aaaaaaaa0778 <+36>:    ret
End of assembler dump.
```

```text { output_lines = "2-13" }
(gdb) info registers sp x29 x30
sp             0xfffffffff580      0xfffffffff580
x29            0x6168632034322065  7018969009222721637
x30            0x736579202e7372    32481193227088754
```

Indeed, registers `x29` and `x30` do not contain the value that they had at the
start of the function. They were supposed to have those values by now though.

The `ret`urn instruction at the end of the function uses the value in register
`x30` as the address to jump to. Let's see what happens. When it executes.


```text { output_lines = "2-13" }
(gdb) nexti
0x0000aaaaaaaa0774      7           return buffer[2];
```

```text { output_lines = "2-13" }
(gdb) nexti
0x0000aaaaaaaa0778      7           return buffer[2];
```

```text { output_lines = "2-13" }
(gdb) disass
Dump of assembler code for function f:
   0x0000aaaaaaaa0754 <+0>:     sub     sp, sp, #0x20
   0x0000aaaaaaaa0758 <+4>:     stp     x29, x30, [sp, #16]
   0x0000aaaaaaaa075c <+8>:     add     x29, sp, #0x10
   0x0000aaaaaaaa0760 <+12>:    mov     x1, x0
   0x0000aaaaaaaa0764 <+16>:    add     x0, sp, #0x8
   0x0000aaaaaaaa0768 <+20>:    bl      0xaaaaaaaa0630 <strcpy@plt>
   0x0000aaaaaaaa076c <+24>:    ldp     x29, x30, [sp, #16]
   0x0000aaaaaaaa0770 <+28>:    ldrb    w0, [sp, #10]
   0x0000aaaaaaaa0774 <+32>:    add     sp, sp, #0x20
=> 0x0000aaaaaaaa0778 <+36>:    ret
End of assembler dump.
```

```text { output_lines = "2-13" }
(gdb) nexti
0x00736579202e7372 in ?? ()
```

```text { output_lines = "2-13" }
(gdb) disass
No function contains program counter for selected frame.
```

```text { output_lines = "2-13" }
(gdb) nexti
Cannot access memory at address 0x736579202e7372
```

Indeed the program counter now points to `0x736579202e7372`. It is not a valid
address. It is not even a 4-byte aligned value, which the program counter always
should be. That results in a "Bus error" signal when we let the program continue
running again:

```text { output_lines = "2-13" }
(gdb) cont
Continuing.

Program received signal SIGBUS, Bus error.
0x00736579202e7372 in ?? ()
```
