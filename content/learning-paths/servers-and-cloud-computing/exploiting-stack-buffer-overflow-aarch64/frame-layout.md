---
title: Frame Layout
weight: 4

### FIXED, DO NOT MODIFY
layout: learningpathall
---

To be able to build a stack buffer overflow-based exploit, we first need to
understand how variables, function arguments, return values and more are laid
out on the stack.

In this section, we will look at how the `clang` compiler lays out stack frame.

Let's look at the following program:

```C
__attribute__((noinline))
long f() {
    volatile char buffer1[4];
    volatile char buffer2[7];
    buffer1[3] = 10;
    buffer2[6] = 20;
    return buffer1[3]+buffer2[6];
}

int main() {
    f();
    return 0;
}
```

Save it as file `stack-layout.c`. You can do this outside the docker container,
so that you can use your favorite editor. Save the file in the directory where
you ran `docker run`. The file will show up in the docker container under path
`/armlearningpaths`.

Compile it with the following command at your docker prompt:

```bash { command_line="root@7a8fb34f810e:/armlearningpaths|2-3" }
clang -O1 -S -fno-asynchronous-unwind-tables stack-layout.c
```

This produces the assembly file `stack-layout.s`. When you open it, you see the
following assembly for function `f`:

```asm
	sub	sp, sp, #16
	mov	w8, #10
	mov	w9, #20
	strb	w8, [sp, #12]
	strb	w9, [sp, #8]
	ldrb	w8, [sp, #12]
	ldrb	w9, [sp, #8]
	add	x0, x9, x8
	add	sp, sp, #16
	ret
```

Here we see that the first instruction `sub sp, sp #16` reserves 16 bytes on the
stack as the stack frame for this function. The stack on AArch64 grows
downwards, i.e. towards lower memory addresses.

The next 4 instructions store value `10` and `20` to `buffer1[3]` and
`buffer2[6]`.

From the offset `[sp, #8]` and `[sp, #12]` we can compute the frame layout.

{{% notice "exercise 1" %}}

Draw the frame layout of function `f`: how are `buffer1` and `buffer2` laid out
in the 16 bytes that are reserved?

TODO: find a way to hide the answer, e.g. by some form of collapsible UI element?

Answer:
```text
\ 
     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
     | x | x |  <-      buffer2     ->   | <- buffer1 -> | x | x | x | <- frame of the main function ->  |
     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 sp+:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23 ....
       ^
       |
       sp

```
{{% /notice %}}



For the `main` function, `clang` produces the following assembly:

```asm
	stp	x29, x30, [sp, #-16]!           // 16-byte Folded Spill
	mov	x29, sp
	bl	f
	mov	w0, wzr
	ldp	x29, x30, [sp], #16             // 16-byte Folded Reload
	ret
```

The `bl f` instruction in the middle performs a function call to function `f`.
It writes the address of the instruction after it -- in this case `mov w0, wzr`
-- to register `x30`. Then is lets the program continue at the first instruction
of function `f`.

Register `x30` is also often called the _link register_, or `lr`.

The `ret` instruction at the end of the main function will branch to the address
stored in register `x30`. The correct address that function `main` should return
to was set by a `bl main` instruction somewhere else in the program.

Because the `bl f` instruction overwrites the value in `x30`, the original value
in `x30` at the start of function `main` needs to be saved somewhere. It is
saved on the stack by the instruction `stp x29, x30, [sp, #-16]!`.

The `stp` instruction is a "store pair" instruction. It stores 2 registers to a
location in memory. The location in memory in this case is `[sp, #-16]!`, i.e.
the address in register `sp` (also known as the stack pointer), at an offset of
-16. The exclamation mark indicates that the value in register `sp` should be
updated to the value with the offset. In other words, after this instruction
executes, `sp` will have a value that is 16 less than before the instruction
executes. `[sp, #-16]!` is a so-called
[Pre-index addressing mode](https://developer.arm.com/documentation/102374/0101/Loads-and-stores---addressing).
  
Register `x29` contains the
"[frame pointer](https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst#the-frame-pointer)",
and is sometimes called `fp`. The frame pointer points to a location in the
stack frame that contains the so-called "frame record". The frame record has two
fields: a pointer to the frame record of the function that called the current
function; and the address the current function needs to return to.

At the start of function `main`, it contains the value of the frame pointer of
the previous function. Since the function `f` that is being called might change
the value of `x29`, that value also needs to be stored in the function prologue.
It will be restored by the instruction `ldp x29, x30, [sp], #16` in the function
epilogue. `[sp], #16` is a
[post-index addressing mode](https://developer.arm.com/documentation/102374/0101/Loads-and-stores---addressing):
it specifies to load from the address in register `sp`, and then to increase the
value in `sp` with 16.

{{% notice "exercise 2" %}}

Draw the frame layout of function `main`.

* Which variables or register values are stored on the stack at which location?
* Where do the frame pointer (`x29`) and stack pointer (`sp`) point to just
  before the call to function `f`, which is done by instruction `bl f`?

{{% /notice %}}

### Answer to exercise 2

TODO: find a way to hide the answer

```text
\ 
     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
     | x29 = fp of previous function | x30 = return address to prev f| <- frame of function that called main->   |
     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 sp+:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  ...
       ^
       |
       sp = x29

```
