---
title: "HW counter access options"
weight: 2
layout: "learningpathall"
---

In this learning path, the terms hardware counter and events counter are used interchangeably.

## About hardware and software events

SW events are typically generated by the kernel or user software. Examples of SW events are context switches and page faults. HW events are generated by the CPU or other system HW. Examples of HW events are instructions executed and CPU cycles completed. The focus of this learning path is on HW events.

## About HW events on Arm

In the Arm architecture, HW events are managed by the Performance Monitoring Unit (PMU). This unit contains the system registers that configure event counting; it is also where counter results are stored. The number of HW events that can be counted in a given period of time is limited. Typically you'll see support for 4-8 counters on a given CPU. The number of supported HW events can be found in the Technical Reference Manual (TRM) of the CPU. There is also a dedicated counter for CPU cycles which does not occupy the 4-8 event slots. Lastly, the PMU supports SW increment counters for user software to count things like access to a specific data structure.

If you need to count more HW events than the CPU supports, this can be achieved by multiplexing different counters over a measurement period. For example, if the CPU only supports 6 counters and you want to measure 12 different events, you can swap in/out a set of 6 events over the measurement period. However, this means that the counter results will need to be scaled and extrapolated over the total measurement period due to the swapping. When multiplexing is implemented, the final scaled counter results should be taken as an estimate of the total events counted. This is ok for most cases but, if your debug/analysis work is done methodically, you can usually narrow down the number of counters needed to a number that doesn't require you to multiplex. This is preferable as it keeps the counter results more accurate and eliminates the need to implement multiplexing (if the counting tool/method you are using does not natively support multiplexing).

### Where to find the list of HW events that can be counted

All available HW events and their unique IDs can be found in the Technical Reference Manual of the CPU. For example, if you are interested in the HW events supported by the Neoverse N2, review the [Neoverse N2 TRM](https://developer.arm.com/documentation/102099/0003/).

### About Arm Exception levels (or execution privilege) and HW counters

It's helpful to have a basic understanding of Arm Exception levels because it affects the counter setup. The [Arm Architecture A-profile reference manual](https://developer.arm.com/documentation/ddi0487/ja/?lang=en) defines 4 exception levels. These are called EL0 (required), EL1 (required), EL2 (optional), and EL3 (optional). For server class Neoverse cores, all 4 levels will usually be implemented because Neoverse based platforms usually need to support virtualization. The easiest way to think of these levels is through the lens of execution privilege. User space code executes in EL0, kernel code executes in EL1, hypervisor code executes in EL2, and firmware executes in EL3. Arm CPUs will enforce this execution privilege at the HW level.

## About the Linux Perf Tool

The [Linux perf tool](https://en.wikipedia.org/wiki/Perf_%28Linux%29) is capable of measuring both SW & HW events. It is used for measuring events at the process or system level. If you want to instrument counting directly in your code then you will need to use one of the other methods discussed in this learning path. That said, it's a good idea to learn how to use this tool anyway. Depending on what you are working on, it could save you the need to instrument counters directly in your code.

## PMU access might not be needed

If all you need to do is count time/cycles, it's possible to use the System Counter instead of the PMU. This requires the least amount of code and is the quickest way to get started.

This learning path contains a walkthrough of using the System Counter for instrumentation.

## Options for accessing event counters from user space

There are different ways to use the Arm PMU to read HW counters from user space. The method you use should be determined by a combination of preference and whatever limitations you may have in your environment.

### Performance Application Programming Interface (PAPI)

[The Performance Application Programming Interface (PAPI)](https://icl.utk.edu/papi/) is a tool for instrumenting SW & HW events in your code. It supports both C/C++ and Fortran. It is easy to get started with because PAPI is well [documented](https://github.com/icl-utk-edu/papi/wiki/). PAPI relies on a library called [libpfm4](https://sourceforge.net/p/perfmon2/libpfm4/ci/master/tree/). libpfm4 uses the Linux perf_events infrastructure to configure and count events. Note also that just because your platform isn't listed as supported by libpfm4, it doesn't mean PAPI won't work as the list of supported CPUs isn't comprehensive. Therefore, it is worth trying PAPI even if you do not see your specific Arm CPU implementation listed. Another advantage of PAPI is that it is capable of managing event multiplexing for you.

This learning path contains a walkthrough of a PAPI based instrumentation example.

### Linux perf_event_open system call

The Linux perf_events infrastructure is another way that SW & HW events can be counted. In fact, libpfm4 and the Linux perf tool both use this infrastructure. The [perf_event_open](https://www.man7.org/linux/man-pages/man2/perf_event_open.2.html)system call can be used to instrument counters in your code. However, if multiplexing of events is required, you will need to implement that yourself. Lastly, the [documentation](https://www.man7.org/linux/man-pages/man2/perf_event_open.2.html) on how to use this infrastructure isn't as good as PAPI, so using the full power of this infrastructure may require some trial and error.

This learning path contains a walkthrough of a [perf_event_open](https://www.man7.org/linux/man-pages/man2/perf_event_open.2.html) based instrumentation example.

### eBPF

The Linux kernel contains a tool called eBPF (or BPF) that can be used for event counting as well. In general, the other methods of counting should be considered first before trying eBPF as this tool is complex. In fact, eBPF should only be used for counting if you are already using eBPF as part of a broader performance investigation. For this reason, this learning path does not contain an example of how to use eBPF for event counting.

## What about non-C/C++ environments?

The easiest way to do this is to write a C library and call into it from your non-C/C++ environment.
